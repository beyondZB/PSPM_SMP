diff --git a/cpukit/include/rtems/score/scheduleredf.h b/cpukit/include/rtems/score/scheduleredf.h
index 91c303c..e574083 100644
--- a/cpukit/include/rtems/score/scheduleredf.h
+++ b/cpukit/include/rtems/score/scheduleredf.h
@@ -42,7 +42,8 @@ extern "C" {
  * 0x7fffffffffffffff, but the user API is limited to uint32_t or int for
  * thread priorities.  Ignore ILP64 targets for now.
  */
-#define SCHEDULER_EDF_MAXIMUM_PRIORITY INT_MAX
+//#define SCHEDULER_EDF_MAXIMUM_PRIORITY INT_MAX
+#define SCHEDULER_EDF_MAXIMUM_PRIORITY 0x7fffffffffffffff
 
 /**
  *  Entry points for the Earliest Deadline First Scheduler.
diff --git a/cpukit/include/rtems/score/scheduleredfsmp.h b/cpukit/include/rtems/score/scheduleredfsmp.h
index 42a77f0..e8b692a 100644
--- a/cpukit/include/rtems/score/scheduleredfsmp.h
+++ b/cpukit/include/rtems/score/scheduleredfsmp.h
@@ -121,6 +121,11 @@ typedef struct {
 
   Subtask_Node * current;
 
+  /*
+   * @brief current job release time
+   */
+  uint64_t release_time;
+
 } Scheduler_EDF_SMP_Node;
 
 
@@ -131,6 +136,39 @@ Subtask_Node * _Scheduler_EDF_SMP_Subtask_Chain_current( Scheduler_EDF_SMP_Node
  * This function may be used in release job function in Rate management mechanism */
 Subtask_Node * _Scheduler_EDF_SMP_Subtask_Chain_reset( Scheduler_EDF_SMP_Node * scheduler_edf_smp_node);
 
+/* get the first subtask_node of task_node
+ */
+Subtask_Node * _Scheduler_EDF_SMP_Subtask_Chain_get_first(Task_Node * task_node);
+
+/* get the Scheduler_EDF_SMP_Node of the_thread
+ */
+Scheduler_EDF_SMP_Node *_get_Scheduler_EDF_SMP_Node(Thread_Control * the_thread);
+
+/* create the pd2 priority
+ */
+uint64_t _pspm_smp_create_priority(double utility, uint32_t d, uint32_t b, uint32_t g);
+
+/**
+ * @brief Performs tick operations depending on the CPU budget algorithm for
+ * each executing thread.
+ *
+ * This routine is invoked as part of processing each clock tick.
+ *
+ * @param[in] scheduler The scheduler.
+ * @param[in] executing An executing thread.
+ */
+void _Scheduler_PSPM_Tick(
+  const Scheduler_Control *scheduler,
+  Thread_Control          *executing
+);
+
+void _Scheduler_PSPM_EDF_Release_job(
+  const Scheduler_Control *scheduler,
+  Thread_Control          *the_thread,
+  Priority_Node           *priority_node,
+  uint64_t                 deadline,
+  Thread_queue_Context    *queue_context
+);
 
 typedef struct {
   /**
@@ -189,9 +227,9 @@ typedef struct {
     _Scheduler_EDF_SMP_Remove_processor, \
     _Scheduler_EDF_SMP_Node_initialize, \
     _Scheduler_default_Node_destroy, \
-    _Scheduler_EDF_Release_job, \
+    _Scheduler_PSPM_EDF_Release_job, \
     _Scheduler_EDF_Cancel_job, \
-    _Scheduler_default_Tick, \
+    _Scheduler_PSPM_Tick, \
     _Scheduler_EDF_SMP_Start_idle, \
     _Scheduler_EDF_SMP_Set_affinity \
   }
diff --git a/cpukit/score/src/scheduleredfsmp.c b/cpukit/score/src/scheduleredfsmp.c
index 6166e04..3cd96d2 100644
--- a/cpukit/score/src/scheduleredfsmp.c
+++ b/cpukit/score/src/scheduleredfsmp.c
@@ -25,6 +25,25 @@
  * @brief This is the core structure to connect PSPM SMP to rtems */
 PSPM_SMP pspm_smp_task_manager;
 
+uint64_t _pspm_smp_create_priority(double utility, uint32_t d, uint32_t b, uint32_t g)
+{
+    uint64_t priority = 0;
+    uint32_t bit_mask_low_31 = 0x7fffffff;
+    uint32_t dd = (d) & bit_mask_low_31;
+    uint32_t bb = (~b & 1);
+    if(utility < 0.5)
+        bb = 0;
+    uint32_t gg = (-g - 1) & bit_mask_low_31;
+
+    priority |= dd;
+    priority <<= 1;
+    priority |= bb;
+    priority <<= 31;
+    priority |= gg;
+//    priority <<= 1;
+
+    return priority;
+}
 
 /* obtain the current subtask of a task node */
 Subtask_Node * _Scheduler_EDF_SMP_Subtask_Chain_current(
@@ -38,7 +57,9 @@ Subtask_Node * _Scheduler_EDF_SMP_Subtask_Chain_current(
     Chain_Node * next = _Chain_Next(&current->Chain);
     scheduler_edf_smp_node->current = RTEMS_CONTAINER_OF(next, Subtask_Node, Chain);
 
-    return current;
+    _Assert(!rtems_chain_is_tail(scheduler_edf_smp_node->task_node.Subtask_Node_queue, scheduler_edf_smp_node->current));
+
+    return scheduler_edf_smp_node->current;
 }
 
 /* reset the current subtask of a task node, and return the first subtask node */
@@ -55,6 +76,167 @@ Subtask_Node * _Scheduler_EDF_SMP_Subtask_Chain_reset(
     return scheduler_edf_smp_node->current;
 }
 
+Subtask_Node * _Scheduler_EDF_SMP_Subtask_Chain_get_first(Task_Node * task_node)
+{
+    Chain_Node * first_node = _Chain_First(& task_node->Subtask_Node_queue );
+
+    /* Set the current pointer to the first subtask node in the task node */
+    Subtask_Node * current = RTEMS_CONTAINER_OF(first_node, Subtask_Node, Chain);
+
+    return current;
+}
+
+Scheduler_EDF_SMP_Node *_get_Scheduler_EDF_SMP_Node(Thread_Control * the_thread)
+{
+    Scheduler_Node *scheduler_node = _Thread_Scheduler_get_home_node( the_thread);
+    return (Scheduler_EDF_SMP_Node *)(scheduler_node);
+}
+
+static void apply_priority(
+  Thread_Control *thread,
+  Priority_Control new_priority
+)
+{
+  Scheduler_Node *scheduler_node = _Thread_Scheduler_get_home_node( thread );
+  scheduler_node->Priority.value = new_priority << 1;
+}
+
+static void change_priority(
+  Thread_Control *thread,
+  Priority_Control new_priority
+)
+{
+  Per_CPU_Control *cpu_self;
+
+  cpu_self = _Thread_Dispatch_disable();
+
+  Thread_queue_Context queue_context;
+
+  apply_priority(thread, new_priority);
+  _Scheduler_Update_priority( thread );
+
+  _Thread_Dispatch_enable( cpu_self );
+}
+
+void _Scheduler_PSPM_Tick(
+  const Scheduler_Control *scheduler,
+  Thread_Control          *executing
+)
+{
+  (void) scheduler;
+
+  /*
+   *  If the thread is not preemptible or is not ready, then
+   *  just return.
+   */
+
+  if ( !executing->is_preemptible )
+    return;
+
+  if ( !_States_Is_ready( executing->current_state ) )
+    return;
+
+  /*
+   *  The cpu budget algorithm determines what happens next.
+   */
+
+  switch ( executing->budget_algorithm ) {
+    case THREAD_CPU_BUDGET_ALGORITHM_NONE:
+      break;
+
+    case THREAD_CPU_BUDGET_ALGORITHM_RESET_TIMESLICE:
+    #if defined(RTEMS_SCORE_THREAD_ENABLE_EXHAUST_TIMESLICE)
+      case THREAD_CPU_BUDGET_ALGORITHM_EXHAUST_TIMESLICE:
+    #endif
+      if ( (int)(--executing->cpu_time_budget) <= 0 ) {
+          Scheduler_EDF_SMP_Node * edf_smp_node = _get_Scheduler_EDF_SMP_Node(executing);
+          Scheduler_SMP_Node *smp_node = (Scheduler_SMP_Node *)edf_smp_node;
+          Subtask_Node * subtask_node = _Scheduler_EDF_SMP_Subtask_Chain_current(edf_smp_node);
+          uint64_t pd2prio = _pspm_smp_create_priority(edf_smp_node->task_node->utility, edf_smp_node->release_time + subtask_node->d * pspm_smp_task_manager.quantum_length, subtask_node->b, subtask_node->g);
+          change_priority(executing, pd2prio);
+//          uint64_t pd2prio = subtask_node->d;
+          printf("\t%d +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ %llx \n", edf_smp_node->task_node->id, smp_node->priority);
+
+        /*
+         *  A yield performs the ready chain mechanics needed when
+         *  resetting a timeslice.  If no other thread's are ready
+         *  at the priority of the currently executing thread, then the
+         *  executing thread's timeslice is reset.  Otherwise, the
+         *  currently executing thread is placed at the rear of the
+         *  FIFO for this priority and a new heir is selected.
+         */
+        _Thread_Yield( executing );
+        executing->cpu_time_budget =
+          rtems_configuration_get_ticks_per_timeslice();
+      }
+      else/* if(executing->cpu_time_budget == rtems_configuration_get_ticks_per_timeslice() - 1)*/
+      {
+          change_priority(executing, 20);
+      }
+      break;
+
+    #if defined(RTEMS_SCORE_THREAD_ENABLE_SCHEDULER_CALLOUT)
+      case THREAD_CPU_BUDGET_ALGORITHM_CALLOUT:
+	if ( --executing->cpu_time_budget == 0 )
+	  (*executing->budget_callout)( executing );
+	break;
+    #endif
+  }
+}
+
+void _Scheduler_PSPM_EDF_Release_job(
+  const Scheduler_Control *scheduler,
+  Thread_Control          *the_thread,
+  Priority_Node           *priority_node,
+  uint64_t                 deadline,
+  Thread_queue_Context    *queue_context
+)
+{
+  (void) scheduler;
+
+  _Thread_Wait_acquire_critical( the_thread, queue_context );
+
+  Scheduler_EDF_SMP_Node * edf_smp_node = _get_Scheduler_EDF_SMP_Node(the_thread);
+  Subtask_Node * subtask_node = _Scheduler_EDF_SMP_Subtask_Chain_reset(edf_smp_node);
+
+  edf_smp_node->release_time = deadline - edf_smp_node->task_node->period;
+
+//  printf("maximum_priority ========== %llx\n", scheduler->maximum_priority);
+  /*
+   * There is no integer overflow problem here due to the
+   * SCHEDULER_PRIORITY_MAP().  The deadline is in clock ticks.  With the
+   * minimum clock tick interval of 1us, the uptime is limited to about 146235
+   * years.
+   */
+  uint64_t pd2prio = _pspm_smp_create_priority(
+          edf_smp_node->task_node->utility,
+          edf_smp_node->release_time + subtask_node->d * pspm_smp_task_manager.quantum_length,
+          subtask_node->b,
+          subtask_node->g
+          );
+  printf("The subtask priority of task %d is %llx\n", edf_smp_node->task_node->id, pd2prio);
+
+  _Priority_Node_set_priority(
+          priority_node,
+          //    SCHEDULER_PRIORITY_MAP( deadline )
+          SCHEDULER_PRIORITY_MAP(pd2prio)
+          //    SCHEDULER_PRIORITY_MAP(subtask_node->d)
+          );
+
+  if ( _Priority_Node_is_active( priority_node ) ) {
+    _Thread_Priority_changed(
+      the_thread,
+      priority_node,
+      false,
+      queue_context
+    );
+  } else {
+    _Thread_Priority_add( the_thread, priority_node, queue_context );
+  }
+
+  _Thread_Wait_release_critical( the_thread, queue_context );
+}
+
 static inline Scheduler_EDF_SMP_Context *
 _Scheduler_EDF_SMP_Get_context( const Scheduler_Control *scheduler )
 {
diff --git a/cpukit/score/src/threaddispatch.c b/cpukit/score/src/threaddispatch.c
index 9cd1e29..ee7472f 100644
--- a/cpukit/score/src/threaddispatch.c
+++ b/cpukit/score/src/threaddispatch.c
@@ -1,6 +1,6 @@
 /**
  * @file
- * 
+ *
  * @brief Dispatch Thread
  * @ingroup ScoreThread
  */
@@ -30,6 +30,10 @@
 #include <rtems/score/wkspace.h>
 #include <rtems/config.h>
 
+#include <rtems/score/scheduleredfimpl.h>
+#include <rtems/score/scheduleredf.h>
+#include <rtems/score/schedulersmp.h>
+
 #if ( CPU_HARDWARE_FP == TRUE ) || ( CPU_SOFTWARE_FP == TRUE )
 Thread_Control *_Thread_Allocated_fp;
 #endif
@@ -170,6 +174,13 @@ static void _Thread_Run_post_switch_actions( Thread_Control *executing )
   _Thread_State_release( executing, &lock_context );
 }
 
+static Scheduler_SMP_Node * thread_get_smp_node(Thread_Control * executing)
+{
+    Scheduler_Node *scheduler_node = _Thread_Scheduler_get_home_node( executing );
+    Scheduler_SMP_Node *edf_node = (Scheduler_SMP_Node *)(scheduler_node);
+    return edf_node;
+}
+
 void _Thread_Do_dispatch( Per_CPU_Control *cpu_self, ISR_Level level )
 {
   Thread_Control *executing;
@@ -195,6 +206,24 @@ void _Thread_Do_dispatch( Per_CPU_Control *cpu_self, ISR_Level level )
     _Thread_Preemption_intervention( cpu_self );
     heir = _Thread_Get_heir_and_make_it_executing( cpu_self );
 
+    //zb +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    if(executing == heir){
+        printf("\t\t\t==%x\t%d\t%llu\n\n", executing->current_state, executing->Object.id, thread_get_smp_node(executing)->priority);
+    }
+    else{
+        printf("\t\t\t%x\t%d -->> %d\t\t%llx -> %llx\t%d\n\n", executing->current_state, executing->Object.id, heir->Object.id, thread_get_smp_node(executing)->priority, thread_get_smp_node(heir)->priority,
+                (thread_get_smp_node(executing)->priority >= thread_get_smp_node(heir)->priority));
+    }
+    if(executing->current_state == STATES_READY &&
+            executing->Start.budget_algorithm == THREAD_CPU_BUDGET_ALGORITHM_RESET_TIMESLICE &&
+            executing->cpu_time_budget != 20 &&
+            heir != executing){
+        printf("\n%d should keep executing!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n", executing->cpu_time_budget);
+//        goto post_switch;
+//          heir = executing;
+    }
+    //zb +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
     /*
      *  When the heir and executing are the same, then we are being
      *  requested to do the post switch dispatching.  This is normally
diff --git a/testsuites/smptests/smppspm01/app.c b/testsuites/smptests/smppspm01/app.c
index 91328d5..28c2a96 100644
--- a/testsuites/smptests/smppspm01/app.c
+++ b/testsuites/smptests/smppspm01/app.c
@@ -5,6 +5,15 @@
  * */
 #include "app.h"
 
+static void my_delay(int ticks)
+{
+  rtems_interval start, stop;
+  start = rtems_clock_get_ticks_since_boot();
+  do {
+    stop = rtems_clock_get_ticks_since_boot();
+  } while ( (stop - start) < ticks  );
+}
+
 void i_servant_0(pspm_smp_message *msg)
 {
   int i;
@@ -66,8 +75,14 @@ void c_servant_0( pspm_smp_message * msg )
       printf("Messages of Task 0 send failed\n");
   }
 
+  for(int j = 0; j < 65; j++)
+  {
+//      rtems_test_busy_cpu_usage(0, 1000000);  //busy for 90000 ns
+      my_delay(1);
+      printf("&");
+  }
 
-
+  printf("c_servant_0 finished\n");
 }
 
 void c_servant_1( pspm_smp_message * msg )
@@ -106,6 +121,15 @@ void c_servant_1( pspm_smp_message * msg )
           }
       }
   }
+
+  for(int j = 0; j < 30; j++)
+  {
+//      rtems_test_busy_cpu_usage(0, 1000000);  //busy for 90000 ns
+      my_delay(1);
+      printf("@");
+  }
+
+  printf("c_servant_1 finished\n");
 }
 
 
diff --git a/testsuites/smptests/smppspm01/init.c b/testsuites/smptests/smppspm01/init.c
index 289f856..07855d6 100644
--- a/testsuites/smptests/smppspm01/init.c
+++ b/testsuites/smptests/smppspm01/init.c
@@ -113,11 +113,14 @@ rtems_task Init(
     /* Obtaining the LCM of task periods */
     lcm = LCM(lcm, task_node->period);
 
+    Subtask_Node * snode = _Scheduler_EDF_SMP_Subtask_Chain_get_first(task_node);
+
     status = rtems_task_create(
       rtems_build_name( 'P', 'T', 'A', task_id+'0' ),
-      2,
+//      _pspm_smp_create_priority(task_node->utility, snode->d * pspm_smp_task_manager.quantum_length, snode->b, snode->g) >> 31,
+      snode->d * pspm_smp_task_manager.quantum_length,
       RTEMS_MINIMUM_STACK_SIZE,
-      RTEMS_DEFAULT_MODES,
+      RTEMS_TIMESLICE,
       RTEMS_DEFAULT_ATTRIBUTES,
       &id[count]
     );
diff --git a/testsuites/smptests/smppspm01/main.c b/testsuites/smptests/smppspm01/main.c
index a11b867..aca0e12 100644
--- a/testsuites/smptests/smppspm01/main.c
+++ b/testsuites/smptests/smppspm01/main.c
@@ -17,8 +17,8 @@ void main()
 
   /* The creation of periodic tasks */
   /* The task start from 0, since every task will be mapped into a element in a array for convenient search */
-  task_nodes[0] = pspm_smp_task_create(0, PERIOD_TASK, 5, 200);
-  task_nodes[1] = pspm_smp_task_create(1, PERIOD_TASK, 6, 100);
+  task_nodes[0] = pspm_smp_task_create(0, PERIOD_TASK, 70, 200);
+  task_nodes[1] = pspm_smp_task_create(1, PERIOD_TASK, 35, 100);
 
   /* The creation of Servant in specific tasks */
   pspm_smp_servant_create(task_nodes[0], i_servant_0, c_servant_0, o_servant_0);
diff --git a/testsuites/smptests/smppspm01/pspm.h b/testsuites/smptests/smppspm01/pspm.h
index e4fe5ce..0c79e4f 100644
--- a/testsuites/smptests/smppspm01/pspm.h
+++ b/testsuites/smptests/smppspm01/pspm.h
@@ -20,7 +20,7 @@
 #include "test_support.h"
 
 /* In number of ticks */
-#define QUANTUM_LENGTH 50
+#define QUANTUM_LENGTH 20
 
 #define TASK_NUM_MAX 20
 
diff --git a/testsuites/smptests/smppspm01/pspmimpl.c b/testsuites/smptests/smppspm01/pspmimpl.c
index 005aede..f03640c 100644
--- a/testsuites/smptests/smppspm01/pspmimpl.c
+++ b/testsuites/smptests/smppspm01/pspmimpl.c
@@ -376,6 +376,7 @@ rtems_task _comp_servant_routine(rtems_task_argument argument)
 
     /* In rtems, periodic tasks are created by rate monotonic mechanism */
     status = rtems_rate_monotonic_period(rate_monotonic_id, period);
+    printf("taskid = %d\t", id);
     directive_failed(status, "rtems_rate_monotonic_period");
 
     /* Receive message from IN_QUEUE of current task */
@@ -431,19 +432,20 @@ static void _pd2_subtasks_create(
     )
 {
   rtems_chain_initialize_empty( &p_tnode->Subtask_Node_queue );
-  uint32_t min_group_deadline = p_tnode->period;
-  for(int i = p_tnode->wcet; i >= 1; i--)
+  uint32_t min_group_deadline = p_tnode->quant_period;
+  for(int i = p_tnode->quant_wcet; i >= 1; i--)
   {
     Subtask_Node *p_new_snode = (Subtask_Node *)malloc(sizeof(Subtask_Node));
     p_new_snode->r = myfloor((double)(i - 1) / p_tnode->utility);
     p_new_snode->d = myceil((double)i / p_tnode->utility);
     p_new_snode->b = myceil((double)i / p_tnode->utility) - myfloor((double)i / p_tnode->utility);
     /* the b(Ti) of the last subtask should be 0 */
-    p_new_snode->b = (i == p_tnode->wcet) ? 0 : p_new_snode->b;
+    p_new_snode->b = (i == p_tnode->quant_wcet) ? 0 : p_new_snode->b;
     _group_deadline_update(p_tnode->utility, p_new_snode, &min_group_deadline);
 
     /* prepend the subtask into subtask node queue */
     rtems_chain_prepend_unprotected( &p_tnode->Subtask_Node_queue, &p_new_snode->Chain );
+    printf("task%d-%d\td = %u\tb = %u\tg = %u\n", p_tnode->id, i, p_new_snode->d, p_new_snode->b, p_new_snode->g);
   }
 }
 
@@ -474,7 +476,7 @@ Task_Node_t  pspm_smp_task_create(
     /*Note that : the quantum length is presented in number of ticks */
     p_tnode->quant_wcet =  myceil((double)p_tnode->wcet / pspm_smp_task_manager.quantum_length);
     p_tnode->quant_period =  myceil((double)p_tnode->period / pspm_smp_task_manager.quantum_length);
-    p_tnode->utility = (double)p_tnode->wcet / p_tnode->period;
+    p_tnode->utility = (double)p_tnode->quant_wcet / p_tnode->quant_period;
 
     /* calculate the PD2 relative timing information for scheduling subtasks */
     _pd2_subtasks_create(p_tnode);
@@ -797,7 +799,7 @@ rtems_status_code _pspm_smp_message_queue_OrC( tid_t id, pspm_smp_message *msg)
 #define CONFIGURE_MICROSECONDS_PER_TICK 1000
 
 /* 1 timeslice == 50 ticks */
-/* #define CONFIGURE_TICKS_PER_TIMESLICE 4 */
+#define CONFIGURE_TICKS_PER_TIMESLICE QUANTUM_LENGTH
 #define CONFIGURE_MAXIMUM_PROCESSORS 1
 
 
